# Runpy Development Understanding

## Project Overview
Runpy is a library that automatically converts Python functions into CLI commands, similar to how FastAPI converts functions into API endpoints.

## Core Concepts

### Function to CLI Conversion
- Takes any Python function and transforms it into a command-line interface
- Leverages FastAPI's schema generation capabilities for parsing function arguments and their descriptions
- Aims to make CLI creation as simple as defining a function with proper type hints

### Generator Class Architecture
- A generator class will be responsible for building the CLI
- Functions are registered one by one to construct the complete command interface
- During registration, shortcuts can be defined using a dictionary format: `{"name": "n", "version": "v"}`

### Command Path Structure
The system supports hierarchical command structures:
```
mycli/mycmd/subcmd
```
This translates to command usage like:
```
mycli mycmd subcmd --name John ...
```
Multiple levels of nesting are supported for complex CLI applications.

### Argument Handling Philosophy
- All parameters are treated as options for simplicity
- No distinction between arguments and flags - everything is an option
- Supports Python's `*args` syntax, which will be processed as regular arguments
- Example: `def func(a: int, b: int, *args: int, c: int):` - the `*args` parameter will be handled appropriately

### Schema Command
Every CLI generated by a class instance will include a built-in `schema` command that:
- Provides API schema-style documentation
- Explains CLI usage patterns
- Auto-generates help documentation from function signatures and docstrings

## Technical Implementation
- Moving from Cleo to Click framework due to better subcommand support
- Click provides more robust handling of nested command structures

## Related Components
- **cli-bridge**: The initial prototype/implementation
- **func-analyzer**: Developed to extract necessary information from functions
  - May become obsolete if FastAPI's built-in capabilities prove sufficient

## Design Goals
- Minimal boilerplate code
- Automatic CLI generation from function signatures
- Intuitive command hierarchies
- Self-documenting through schema generation
- Leverage existing tools (FastAPI patterns, Click framework) rather than reinventing the wheel